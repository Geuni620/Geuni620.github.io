{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/2024/8/11/is-loading-is-fetching/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6449a3e5e013527fca52bdf867f0fc71/d71bc/img.webp\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRtAAAABXRUJQVlA4IMQAAAAQBQCdASoUABQAPtFgqE+oJSOiKAgBABoJQA8Ul2ADLoXDwpKA/qSGeZU2ADFXQAZAAP7aiZuEHBpoiz3EgmMsc7qJtei/OGzxiPJPFcjXBeIITKfVknWaFvAECpiP1Y9n9m/IS/7lpbxsoJ1lJWoati+k2Ia3Qm6HADLYuadhRTzDBC6EHQaks7APeZ74iiDef8VZ8+e0tF5nvLEQ9+1fS4Ib4bawEKf6DQRMKRmDLKIPh7RxWtFEkNz5cJZ20z6qwAAA'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/6449a3e5e013527fca52bdf867f0fc71/a59e9/img.webp 192w,\n/static/6449a3e5e013527fca52bdf867f0fc71/0ca9f/img.webp 384w,\n/static/6449a3e5e013527fca52bdf867f0fc71/dc9b9/img.webp 768w,\n/static/6449a3e5e013527fca52bdf867f0fc71/d71bc/img.webp 1024w\"\n              sizes=\"(max-width: 768px) 100vw, 768px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/6449a3e5e013527fca52bdf867f0fc71/a59e9/img.webp 192w,\n/static/6449a3e5e013527fca52bdf867f0fc71/0ca9f/img.webp 384w,\n/static/6449a3e5e013527fca52bdf867f0fc71/dc9b9/img.webp 768w,\n/static/6449a3e5e013527fca52bdf867f0fc71/d71bc/img.webp 1024w\"\n            sizes=\"(max-width: 768px) 100vw, 768px\"\n            type=\"image/webp\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/6449a3e5e013527fca52bdf867f0fc71/dc9b9/img.webp\"\n            alt=\"img\"\n            title=\"img\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p><a href=\"https://github.com/Geuni620/isLoading-isFetching\" target=\"_blank\" rel=\"nofollow\">예시 소스코드</a></p>\n<blockquote>\n<p>얼마 전 회사에서, 작은 경험을 했는데, 어디 남겨 놓을까 하다가<br>\n결국 블로그에 쓰게됐다.</p>\n</blockquote>\n<p>먼저 간단한 테스트해보았다.<br>\n만약 이런 경우라면 어떻게 되는걸까?</p>\n<ol>\n<li>queryKey에 해당하는 데이터가 cacheTime 내 존재한다.</li>\n<li>다른 페이지로 이동 <code class=\"language-text\">/home → /details</code></li>\n<li>cacheTime 내 다시 해당 페이지로 접속 <code class=\"language-text\">/details → /home</code></li>\n</ol>\n<br/>\n<p>이때 isLoading과 isFetching은 각각 어떻게 되는 것일까?<br>\n그리고, 만약 cacheTime 내 다시 해당 페이지로 접속했을 때,<br>\n외부환경에 의해 DB의 데이터가 변경됐다면, 3의 데이터는 변경된 데이터를 노출할까?</p>\n<br/>\n<p>간단한 예시를 만들어봤고, 테스트해봤다.<br>\ncacheTime와 staleTime 각각 default 값을 사용했다. (5min, 0s)<br>\n결과는 다음과 같다.</p>\n<blockquote>\n<p>3.에서 isLoading과 isFetching은 각각 어떻게 되는 것일까?</p>\n</blockquote>\n<p><strong>isLoading은 false를, isFetching은 true를 반환할 것이다.</strong><br>\nisLoading은 캐싱된 데이터가 없고, queryKey에 해당하는 첫 데이터를 가져올 때, <strong>true</strong>가 된다.<br>\n1에서 캐싱된 데이터가 존재한다고 했으니, false를 반환한다.</p>\n<p>isFetching은, staleTime이 만료되었으면, 캐싱된 데이터가 존재하더라도, <strong>true</strong>이다.\n3으로 이동했을 때, staleTime이 만료된 이후이기에, true를 반환할 것이다.</p>\n<p>여기서, 캐싱된 데이터라고 언급한 것은 모두 cacheTime이 만료되지 않은 상태의 데이터이다.</p>\n<br/>\n<blockquote>\n<p>만약 cacheTime 내 다시 해당 페이지로 접속했을 때,<br>\n외부환경에 의해 DB의 데이터가 변경됐다면, 3.의 데이터는 변경된 데이터를 노출할까?</p>\n</blockquote>\n<p>1, 2의 과정을 거쳤고, 3의 과정을 수행하기 전, DB의 데이터가 변경됐다.<br>\n그리고, 3.의 과정을 수행했다.</p>\n<p>그럼 isLoading은 여전히 false이다. 하지만 isFetching은 true가 된다.<br>\n만약, isLoading을 통해 스켈레톤UI 작업을 해놓았다면, 스켈레톤 UI는 보이지 않는다.</p>\n<p>하지만, isFetching이 true이기 때문에, 페이지에 접속했을 땐, cacheTime이 만료 전이라, 캐싱된 데이터를 노출하고,<br>\nisFetching이 true → false로 변경될 때, 새롭게 불러온 신선한 데이터로 변경될 것이다.</p>\n<p><img src=\"/25b735ad42cdcb5991c4d70dfcb48446/ex.gif\" alt=\"테이블 내 &#x27;테스트25&#x27;가 노출되었다가, &#x27;테스트50&#x27;으로 변경되는 것을 볼 수 있다.\"></p>\n<br/>\n<blockquote>\n<p>만약, staleTime을 0ms → 5min으로 변경했을 때, 3.의 데이터는 변경된 데이터를 노출할까?</p>\n</blockquote>\n<p>노출하지 않는다. staleTime이 만료되기 전이라, isLoading, isFetching 모두 false이고,<br>\n3.의 데이터 역시 stale한 데이터(변경되기 전)를 노출한다.</p>\n<br/>\n<hr>\n<p>그럼 회사에서 겪었던 문제는 무엇이었을까?</p>\n<p>출고에 관련된 데이터를 검색하기 위해선, 해당 화주사 리스트가 필요하다.<br>\n이 리스트를 기존에는 클라이언트 상태로 관리하다가, 서버상태로 변경했다.<br>\n그리고, 이 서버상태를 가지고 API를 호출한다.</p>\n<p>출고에 관련된 API를 쏘기 전, 화주사 리스트가 isLoading 상태인지 검증하고,<br>\nisLoading이 false일 경우, API를 호출하도록 해줬다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">isLoading ? [] : 호출</code></pre></div>\n<br/>\n<p>근데 문제가 발생했다.<br>\n센터를 고려하지 못했던 것이다.</p>\n<p>A유저가 A센터로 로그인<br>\n> 출고에 관련된 데이터를 호출<br>\n> 로그아웃 후 로그인 페이지로 이동</p>\n<p>A유저가 B센터로 로그인<br>\n> 출고에 관련된 데이터 호출</p>\n<ul>\n<li>이때 호출된 데이터는 화주사리스트에 isLoading fasle이고, isFetching은 true이다.</li>\n<li>isLoading이 fasle 이니, 캐싱된 데이터를 사용해서 API를 쏜다. (A센터 화주리스트로 API를 호출함)</li>\n<li>isFetching은 true이니, 변경된 화주사 리스트로 API를 다시 호출한다. (레거시 코드라 API 호출은 일부 useEffect로 호출함)</li>\n<li>그리고 setState 과정에서, 변경된 화주사 리스트로 업데이트 했다가, isFetching이 true로 변경되고, 다시 기존 데이터로 setState 해버린다.</li>\n<li>명확히 원인을 파악하지 못했다. 해결책으론 isLoading 했던 부분을 isFetching으로 변경하니 잘 적용된다는 점이다.</li>\n</ul>\n<br/>\n<hr>\n<blockquote>\n<p>원인을 발견했다.<br>\n위 회사에서 겪었던 문제에 대해 설명이 조금 미흡한 것 같아서 자세히 적어보려고 한다.</p>\n</blockquote>\n<p>먼저, legacy(이하 레거시) 코드는 useEffect를 통해 API를 호출하고 있으며, 새롭게 만드는 것, 또는 기존에 사용되어오던 클라이언트 상태관리(ex redux)는 점진적으로 서버 상태로 변경하는 중이다.</p>\n<p>위 예시는, 레거시 코드와 서버상태의 동기화가 필요했고, 그 과정에서 useEffect depnedency array(이하 디펜던시 어레이) 안에 isFetching flag를 넣어놓은 상태이다.</p>\n<p>처음엔, isLoading을 넣었으나, 센터를 변경하는 과정에서, invalidateQueries를 설정해놓지 않아, isLoading으로 적용했을 때, 캐싱된 데이터를 그대로 사용하게 되고, 그 과정에서 센터변경에 따른 새로운 데이터를 호출하지 않고, 기존 데이터를 그대로 렌더링하는 문제가 발생했다.<br>\n(ex. A센터에서 B센터로 변경했으나, B센터 데이터가 아닌, A센터 데이터가 렌더링 됨)</p>\n<p>그래서, isFetching으로 flag를 변경해놓았는데, 조회 API를 호출할 때, payload로 사용되는 화주사 리스트에 isFetching으로 변경하는 걸 놓치고, isLoading 상태를 유지했던 것이다.</p>\n<p>이 때문에, 센터가 변경됐지만, 해당 데이터의 업데이트는 적절히 이뤄지지 않았던 것이다.</p>\n<br/>\n<p>사실, useEffect 내, isLoading을 isFetching으로 변경했을 때, 센터변경에 따른 데이터 변경이 적절히 이뤄졌었다. 하지만 예외 상황이 있었던 것이다.</p>\n<p>그건, 바로 서버의 응답이 늦는, 즉, 센터의 데이터가 많아서 서버의 응답이 오래 걸리는 경우에 문제가 발생했다.</p>\n<p>다음과 같은 상황인데, 위 사례를 그대로 들어서 설명해보겠다.</p>\n<p>A유저가 A센터로 로그인<br>\n> 출고에 관련된 데이터를 호출 (이때 데이터 응답시간이 오래걸림, 하지만 기존에 캐싱된 데이터가 없으니 문제되지 않음)</p>\n<p>> 로그아웃 후 로그인 페이지로 이동</p>\n<p>A유저가 B센터로 로그인<br>\n> 출고에 관련된 데이터 호출 (이때, B센터는 A센터에 비해 응답속도가 빠르다. 즉, useEffect의 디펜던시 어레이에 isFetching으로 변경 후엔, 데이터가 잘 반영되는게 맞다. 하지만, B센터는 A센터에 비해 응답속도가 늦고, 이는 B센터로 데이터가 setState 됐지만, A센터의 응답이 이 이후에 도착하게 되고, setState가 동작하게 된다. 그러면 결국 B센터의 데이터는 (늦게 도착한) A센터의 데이터로 덮혀씌워지게 된다.)</p>\n<p>> 그래서 결국 B센터로 변경했음에도 불구하고, A센터의 데이터가 노출됐던 것이다.<br>\n(A센터 응답시간 약 500ms, B센터 응답시간 20ms)</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">isFetching ? [] : 호출</code></pre></div>\n<p>기존 loading에서 isFetching으로 변경하고 나서는 적절히 반영된다.</p>\n<p>A유저가 A센터로 로그인<br>\n> 출고에 관련된 데이터를 호출\n> 로그아웃 후 로그인 페이지로 이동</p>\n<p>A유저가 B센터로 로그인<br>\n> 출고에 관련된 데이터 호출</p>\n<p>isFetching으로 변경한 후의 변화는, A유저가 B센터로 로그인 한 뒤, 출고에 관련된 데이터를 호출할 때, 기존 isLoading일 때와 다르게 isFetching에 의해 B센터에 관련된 화주사 리스트를 반영하고 난 뒤에, 조회 API를 호출한다는 점이다.</p>\n<br/>\n<h3 id=\"고찰\" style=\"position:relative;\"><a href=\"#%EA%B3%A0%EC%B0%B0\" aria-label=\"고찰 permalink\" class=\"headerElement before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>고찰</h3>\n<p>사실 이 모든 문제의 가장 적절한 해결은, invalidateQueries를 설정해서 로그아웃 및 로그인 시, 적절한 화주사 리스트를 가져오면 해결될 문제다.</p>\n<p>하지만 이를 놓치고, isLoading과 isFetching의 flag로 문제를 해결하려다 보니, 결국 더 깊은 미궁으로 빠져들게 됐다.</p>\n<p>물론 이 문제를 해결하는 과정에서, query를 더 잘 이해하게 된 것도 있지만, 가장 큰 수확은 디버깅이다.</p>\n<p>해당 문제를 해결하기 위해, 코드 내 debugger를 심어놓고 브라우저에서 해당 디버거의 동작을 순차적으로 적용했는데, 문제 해결에 도움이 됐다.</p>\n<p>해당 문제에 대한 재현은 동일하게 코드로 만들어보고, 다음 블로그에 작성할 예정이다.</p>","tableOfContents":"<ul>\n<li><a href=\"#%EA%B3%A0%EC%B0%B0\">고찰</a></li>\n</ul>","frontmatter":{"title":"isLoading과 isFetching","summary":"개인적으로 인상 깊었던 경험을 기록해봄.","date":"2024.08.11.","categories":["개발"]}}}]}},"pageContext":{"slug":"/blog/2024/8/11/is-loading-is-fetching/"}},"staticQueryHashes":["1629908903"]}