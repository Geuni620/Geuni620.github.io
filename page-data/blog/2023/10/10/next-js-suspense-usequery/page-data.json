{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/2023/10/10/next-js-suspense-usequery/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p><a href=\"https://geuni620.github.io/blog/2023/10/3/next-js-suspense-usequery/\" target=\"_blank\" rel=\"nofollow\">next.js에서 useQuery + Suspense를 사용했을 때 fallback ui가 보이지 않는다. -1</a></p>\n<p>첫 번째 글에서 해결하지 못했던 문제가 있었다.</p>\n<ul>\n<li>왜 useQuery + Suspense를 사용해서 새로고침을 연발하면 어느순간 cache가 되는가?</li>\n</ul>\n<br>\n<p>우연히 열어놓은 Next.js 공식문서에서 <a href=\"https://nextjs.org/docs/app/building-your-application/optimizing/lazy-loading\" target=\"_blank\" rel=\"nofollow\">Lazy loading</a>을 찾았다.\n위 글에선 다음과 같이 작성되어있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Next.js의 지연 로딩은 경로를 렌더링하는 데 필요한 JavaScript의 양을 줄여\n애플리케이션의 초기 로딩 성능을 개선하는 데 도움이 됩니다.\n\n이를 통해 클라이언트 컴포넌트와 가져온 라이브러리의 로딩을 지연시키고 필요할 때만 클라이언트 번들에 포함할 수 있습니다.\n예를 들어 사용자가 클릭하여 모달을 열 때까지 로딩을 지연시키고 싶을 수 있습니다.\n\n(중략)\n\n기본적으로 서버 컴포넌트는 자동으로 코드 분할되며,\n스트리밍을 사용하여 서버에서 클라이언트로 UI 조각을 점진적으로 전송할 수 있습니다.\n\n지연 로딩은 클라이언트 컴포넌트에 적용됩니다.</code></pre></div>\n<ul>\n<li>서버컴포넌트는 자동으로 lazy loading, 즉 Streaming 된다.</li>\n<li>그리고 클라이언트에선 dynamic을 적용하면 lazy loading 되기 때문에 새로고침 할 때마다 로딩 fallback이 보였다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token string\">'use client'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> dynamic <span class=\"token keyword\">from</span> <span class=\"token string\">'next/dynamic'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Suspense <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> UsequeryComp <span class=\"token operator\">=</span> <span class=\"token function\">dynamic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./components/UsequeryComp'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  ssr<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">loading</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">useQuery loading...</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Home</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>flex items-center justify-center bg-blue-500<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n          </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UsequeryComp</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<ul>\n<li>그럼 useQuery + Suspense에서 lazy loading을 적용하지 않으면(=react의 lazy 또는 next의 dynamic을 사용하지 않으면), import는 lazy loading 되지 않는다.<br>\n즉, 새로고침해도 그때그때 로딩해서 번들에 포함시키는 게 아닌, 이미 번들에 포함되어 있었던 건 아닐까?</li>\n</ul>\n<br>\n<ul>\n<li>위와 같은 생각을 하던 찰나, 아래 공식문서에 이와 같이 적혀있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SSR 건너뛰기\nReact.lazy() 및 Suspense를 사용할 때, 클라이언트 컴포넌트는 기본적으로 사전 렌더링(SSR)됩니다.\n\n클라이언트 컴포넌트에 대해 사전 렌더링을 사용하지 않으려면 ssr 옵션을 false로 설정하면 됩니다:</code></pre></div>\n<ul>\n<li>아하…! useQuery + Suspense를 사용하면 <strong>사전 SSR이 되는 것이다.</strong></li>\n<li>그렇다면 서버로부터 HTML로 그려서 오는데, 데이터가 그 사이에 resolve 되면 HTML에 데이터가 포함되어 오는 것이고, 데이터가 pending이라면 loading fallback이 그려져서 오는 것이다.</li>\n</ul>\n<br>\n<h3 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"headerElement before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h3>\n<blockquote>\n<p>확실하진 않으나, 추측상으론</p>\n</blockquote>\n<p>cache 되는 것이 아니라, 사전 SSR에 의해 서버로부터 이미 HTML에 데이터가 포함되어서 오는 것이었다.</p>\n<br>\n<h3 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"headerElement before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h3>\n<p><a href=\"https://nextjs.org/docs/app/building-your-application/optimizing/lazy-loading\" target=\"_blank\" rel=\"nofollow\">Lazy loading</a></p>","tableOfContents":"<ul>\n<li><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\">참고자료</a></li>\n</ul>","frontmatter":{"title":"next.js에서 useQuery + Suspense를 사용했을 때 fallback ui가 보이지 않는다. -2","summary":"원인을 찾은 것 같기도...","date":"2023.10.10.","categories":["개발"]}}}]}},"pageContext":{"slug":"/blog/2023/10/10/next-js-suspense-usequery/"}},"staticQueryHashes":["1629908903"]}