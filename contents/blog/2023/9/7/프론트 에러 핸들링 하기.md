---
date: '2023-09-07'
title: '프론트 에러 핸들링하기'
categories: ['next.js', 'error', 'errorboundary', 'tanstack-query']
summary: 'next.js app dir, tanstack-query, Errorboundary를 이용해서 에러를 핸들링해보자.'
---

> 점차 한 프로덕트를 만들어갈 수록 중요하다고 생각되는 점이 크게 두 가지 있다.

1. 첫 번째는 테스트코드이다.
   TDD를 하고 있진 않는데, 이런 상황이 생기면 꼭 테스트코드를 작성하려고 한다.  
   예를 들어, 한 에러가 발생했는데, 이 에러가 어디서 발생했는지, 왜 발생했는지, 그리고 여러번 이 에러가 발생해서 수정해줬어야했을 때.  
   이럴 땐 꼭 테스트코드를 작성하려고 한다.

<br>
   
2. 두 번째는, 에러 분기처리다.
   기존에는 console.error로 로깅만 했었는데, 문구도 network is not working 정도로만 작성했다.   
   `status`나 `message`를 따로 처리하지 않고 그저 string으로만 처리하는 상황이었다.    
   그 후, 같은 에러 문구가 여러 곳에서 뜨니 어디가 어딘지 알 수가 없었다.   
   그래서 에러를 한 번 정리해줄 필요성이 있었고, 이 글을 쓰게 됐다.

<br>

먼저 현재 사용하고 있는 기술스택은 다음과 같다

- next.js, app dir
- tanstack-query
- Errorboundary

먼저 프론트 에러처리부터 작성해보려고 한다.

### tanstack-query error

다음의 글을 참고했다.

[Status Checks in React Query](https://tkdodo.eu/blog/status-checks-in-react-query)  
[React Query Error Handling](https://tkdodo.eu/blog/react-query-error-handling)  
[[번역] React Query API의 의도된 중단](https://velog.io/@cnsrn1874/breaking-react-querys-api-on-purpose)

순서대로 읽는 걸 권하고 싶다.
맨 마지막 글을 읽으며, tanstack-query v5에선 onError, onSuccess, onSettled가 없어졌다는 것을 알게 됐다. 사실 알게 된건 몇 달 전이었던 것 같은데, `문제에 직면하지 않아서` 따로 찾아보지 않았다. 당시엔 server component에 대한 문제를 해결하기 바빴다.

<br>

그래서 먼저, useQuery 내에서 onSuccess와 onError를 제거해주었다.

```TSX
// useRecordGetQuery.ts
const getMessage = async (
  userEmail: string | null | undefined,
  token: string | undefined,
) => {
  const encodedEmail = encodeURIComponent(userEmail || '');
  const res = await fetch(
    `${process.env.NEXT_PUBLIC_SERVER_URL}/api/record/${encodedEmail}`,
    {
      method: 'GET',
      headers: {
        authorization: `Bearer ${token}`,
      },
    },
  );

  if (!res.ok) {
    throw new Error('메세지를 가져오는 getMessage에서 오류가 발생했어요.');
  }

  return res.json();
};

export const useRecordGetQuery = (
  userEmail: string | null | undefined,
  token: string | undefined,
) => {
  const { data: messages = [] } = useQuery(
    [...recordManagerKeys.record, userEmail],
    () => getMessage(userEmail, token),
    {
      enabled: !!userEmail,
      select: (data: Message[]) => data.map(decodeMessages),
    },
  );

  return {
    messages,
  };
};
```

- 사실 여기선 select를 사용하고 있는데, 이 또한 onSuccess와 유사하기 때문에 onSuccess라고 생각하고 작성한다.
- 참고로 useQuery 내에 callback만 제거된다. useMutation에선 콜백에 여전히 존재한다.
  - useMutation에서 onSuccess는 invalidateQueries를 무효화할 때 필수적이기 때문에 제거하면, tanck-query를 사용할 이유가 많이 사라질 것이라고 개인적으로 생각한다.

<br>

먼저 useQuery 내에서 Error부터 처리해주려고한다.
fetch API를 사용하고 있어서, if(!res.ok)와 같이 따로 분기처리를 해주어야한다.
사실 조금 고민이었던 점은 fetch 함수를 사용하지않고 axios를 쓸까도 고민했다. 클라이언트컴포넌트에선 axios를, 서버컴포넌트에선 fetchAPI를.
하지만 axios를 사용할 경우 따로 cache 작업을 해주어야하는 것 같다.
[]()

<br>

```TSX

```
