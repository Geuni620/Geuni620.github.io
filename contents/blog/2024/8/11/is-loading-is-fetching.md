---
date: '2024-08-11'
title: 'isLoading과 isFetching'
categories: ['개발']
summary: '개인적으로 인상 깊었던 경험을 기록해봄.'
---

![](./img.webp)

[예시 소스코드](https://github.com/Geuni620/isLoading-isFetching)

> 얼마 전 회사에서, 작은 경험을 했는데, 어디 남겨 놓을까 하다가  
> 결국 블로그에 쓰게됐다.

먼저 간단한 테스트해보았다.  
만약 이런 경우라면 어떻게 되는걸까?

1.  queryKey에 해당하는 데이터가 cacheTime 내 존재한다.
2.  다른 페이지로 이동 `/home → /details`
3.  cacheTime 내 다시 해당 페이지로 접속 `/details → /home`

<br/>

이때 isLoading과 isFetching은 각각 어떻게 되는 것일까?  
그리고, 만약 cacheTime 내 다시 해당 페이지로 접속했을 때,  
외부환경에 의해 DB의 데이터가 변경됐다면, 3의 데이터는 변경된 데이터를 노출할까?

<br/>

간단한 예시를 만들어봤고, 테스트해봤다.  
cacheTime와 staleTime 각각 default 값을 사용했다. (5min, 0s)  
결과는 다음과 같다.

> 3.에서 isLoading과 isFetching은 각각 어떻게 되는 것일까?

**isLoading은 false를, isFetching은 true를 반환할 것이다.**  
isLoading은 캐싱된 데이터가 없고, queryKey에 해당하는 첫 데이터를 가져올 때, **true**가 된다.  
1에서 캐싱된 데이터가 존재한다고 했으니, false를 반환한다.

isFetching은, staleTime이 만료되었으면, 캐싱된 데이터가 존재하더라도, **true**이다.
3으로 이동했을 때, staleTime이 만료된 이후이기에, true를 반환할 것이다.

여기서, 캐싱된 데이터라고 언급한 것은 모두 cacheTime이 만료되지 않은 상태의 데이터이다.

<br/>

> 만약 cacheTime 내 다시 해당 페이지로 접속했을 때,  
> 외부환경에 의해 DB의 데이터가 변경됐다면, 3.의 데이터는 변경된 데이터를 노출할까?

1, 2의 과정을 거쳤고, 3의 과정을 수행하기 전, DB의 데이터가 변경됐다.  
그리고, 3.의 과정을 수행했다.

그럼 isLoading은 여전히 false이다. 하지만 isFetching은 true가 된다.  
만약, isLoading을 통해 스켈레톤UI 작업을 해놓았다면, 스켈레톤 UI는 보이지 않는다.

하지만, isFetching이 true이기 때문에, 페이지에 접속했을 땐, cacheTime이 만료 전이라, 캐싱된 데이터를 노출하고,  
isFetching이 true → false로 변경될 때, 새롭게 불러온 신선한 데이터로 변경될 것이다.

![테이블 내 '테스트25'가 노출되었다가, '테스트50'으로 변경되는 것을 볼 수 있다.](./ex.gif)

<br/>

> 만약, staleTime을 0ms → 5min으로 변경했을 때, 3.의 데이터는 변경된 데이터를 노출할까?

노출하지 않는다. staleTime이 만료되기 전이라, isLoading, isFetching 모두 false이고,  
3.의 데이터 역시 stale한 데이터(변경되기 전)를 노출한다.

<br/>

---

그럼 회사에서 겪었던 문제는 무엇이었을까?

출고에 관련된 데이터를 검색하기 위해선, 해당 화주사 리스트가 필요하다.  
이 리스트를 기존에는 클라이언트 상태로 관리하다가, 서버상태로 변경했다.  
그리고, 이 서버상태를 가지고 API를 호출한다.

출고에 관련된 API를 쏘기 전, 화주사 리스트가 isLoading 상태인지 검증하고,  
isLoading이 false일 경우, API를 호출하도록 해줬다.

```
isLoading ? [] : 호출
```

<br/>

근데 문제가 발생했다.  
센터를 고려하지 못했던 것이다.

A유저가 A센터로 로그인  
\> 출고에 관련된 데이터를 호출  
\> 로그아웃 후 로그인 페이지로 이동

A유저가 B센터로 로그인  
\> 출고에 관련된 데이터 호출

- 이때 호출된 데이터는 화주사리스트에 isLoading fasle이고, isFetching은 true이다.
- isLoading이 fasle 이니, 캐싱된 데이터를 사용해서 API를 쏜다. (A센터 화주리스트로 API를 호출함)
- isFetching은 true이니, 변경된 화주사 리스트로 API를 다시 호출한다. (레거시 코드라 API 호출은 일부 useEffect로 호출함)
- 그리고 setState 과정에서, 변경된 화주사 리스트로 업데이트 했다가, isFetching이 true로 변경되고, 다시 기존 데이터로 setState 해버린다.
- 명확히 원인을 파악하지 못했다. 해결책으론 isLoading 했던 부분을 isFetching으로 변경하니 잘 적용된다는 점이다.

<br/>

---

> 원인을 발견했다.  
> 위 회사에서 겪었던 문제에 대해 설명이 조금 미흡한 것 같아서 자세히 적어보려고 한다.

먼저, legacy(이하 레거시) 코드는 useEffect를 통해 API를 호출하고 있으며, 새롭게 만드는 것, 또는 기존에 사용되어오던 클라이언트 상태관리(ex redux)는 점진적으로 서버 상태로 변경하는 중이다.

위 예시는, 레거시 코드와 서버상태의 동기화가 필요했고, 그 과정에서 useEffect depnedency array(이하 디펜던시 어레이) 안에 isFetching flag를 넣어놓은 상태이다.

처음엔, isLoading을 넣었으나, 센터를 변경하는 과정에서, invalidateQueries를 설정해놓지 않아, isLoading으로 적용했을 때, 캐싱된 데이터를 그대로 사용하게 되고, 그 과정에서 센터변경에 따른 새로운 데이터를 호출하지 않고, 기존 데이터를 그대로 렌더링하는 문제가 발생했다.  
(ex. A센터에서 B센터로 변경했으나, B센터 데이터가 아닌, A센터 데이터가 렌더링 됨)

그래서, isFetching으로 flag를 변경해놓았는데, 조회 API를 호출할 때, payload로 사용되는 화주사 리스트에 isFetching으로 변경하는 걸 놓치고, isLoading 상태를 유지했던 것이다.

이 때문에, 센터가 변경됐지만, 해당 데이터의 업데이트는 적절히 이뤄지지 않았던 것이다.

<br/>

사실, useEffect 내, isLoading을 isFetching으로 변경했을 때, 센터변경에 따른 데이터 변경이 적절히 이뤄졌었다. 하지만 예외 상황이 있었던 것이다.

그건, 바로 서버의 응답이 늦는, 즉, 센터의 데이터가 많아서 서버의 응답이 오래 걸리는 경우에 문제가 발생했다.

다음과 같은 상황인데, 위 사례를 그대로 들어서 설명해보겠다.

A유저가 A센터로 로그인  
\> 출고에 관련된 데이터를 호출 (이때 데이터 응답시간이 오래걸림, 하지만 기존에 캐싱된 데이터가 없으니 문제되지 않음)

\> 로그아웃 후 로그인 페이지로 이동

A유저가 B센터로 로그인  
\> 출고에 관련된 데이터 호출 (이때, B센터는 A센터에 비해 응답속도가 빠르다. 즉, useEffect의 디펜던시 어레이에 isFetching으로 변경 후엔, 데이터가 잘 반영되는게 맞다. 하지만, B센터는 A센터에 비해 응답속도가 늦고, 이는 B센터로 데이터가 setState 됐지만, A센터의 응답이 이 이후에 도착하게 되고, setState가 동작하게 된다. 그러면 결국 B센터의 데이터는 (늦게 도착한) A센터의 데이터로 덮혀씌워지게 된다.)

\> 그래서 결국 B센터로 변경했음에도 불구하고, A센터의 데이터가 노출됐던 것이다.  
(A센터 응답시간 약 500ms, B센터 응답시간 20ms)

<br/>

```
isFetching ? [] : 호출
```

기존 loading에서 isFetching으로 변경하고 나서는 적절히 반영된다.

A유저가 A센터로 로그인  
\> 출고에 관련된 데이터를 호출
\> 로그아웃 후 로그인 페이지로 이동

A유저가 B센터로 로그인  
\> 출고에 관련된 데이터 호출

isFetching으로 변경한 후의 변화는, A유저가 B센터로 로그인 한 뒤, 출고에 관련된 데이터를 호출할 때, 기존 isLoading일 때와 다르게 isFetching에 의해 B센터에 관련된 화주사 리스트를 반영하고 난 뒤에, 조회 API를 호출한다는 점이다.

<br/>

### 고찰

사실 이 모든 문제의 가장 적절한 해결은, invalidateQueries를 설정해서 로그아웃 및 로그인 시, 적절한 화주사 리스트를 가져오면 해결될 문제다.

하지만 이를 놓치고, isLoading과 isFetching의 flag로 문제를 해결하려다 보니, 결국 더 깊은 미궁으로 빠져들게 됐다.

물론 이 문제를 해결하는 과정에서, query를 더 잘 이해하게 된 것도 있지만, 가장 큰 수확은 디버깅이다.

해당 문제를 해결하기 위해, 코드 내 debugger를 심어놓고 브라우저에서 해당 디버거의 동작을 순차적으로 적용했는데, 문제 해결에 도움이 됐다.

해당 문제에 대한 재현은 동일하게 코드로 만들어보고, 다음 블로그에 작성할 예정이다.
